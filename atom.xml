<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://blog.te.6foo.cn</id>
    <title>Idea Touch</title>
    <updated>2020-03-26T07:43:55.405Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://blog.te.6foo.cn"/>
    <link rel="self" href="https://blog.te.6foo.cn/atom.xml"/>
    <subtitle>填不填的都是坑</subtitle>
    <logo>https://blog.te.6foo.cn/images/avatar.png</logo>
    <icon>https://blog.te.6foo.cn/favicon.ico</icon>
    <rights>All rights reserved 2020, Idea Touch</rights>
    <entry>
        <title type="html"><![CDATA[vue项目的卡白屏优化]]></title>
        <id>https://blog.te.6foo.cn/post/vue-xiang-mu-de-qia-bai-ping-you-hua</id>
        <link href="https://blog.te.6foo.cn/post/vue-xiang-mu-de-qia-bai-ping-you-hua">
        </link>
        <updated>2020-01-14T03:04:37.000Z</updated>
        <content type="html"><![CDATA[<h1 id="填坑原因">填坑原因</h1>
<p>一个基于vue vant wexin开发的项目，首屏加载居然有接近3m，网不好就卡白屏了，不能忍</p>
<h1 id="方案">方案</h1>
<ol>
<li>开启gzip</li>
<li>路由懒加载</li>
<li>ui组件按需加载</li>
<li>部分插件通过cdn引用</li>
<li>首屏html增加动画效果，减少焦虑感</li>
</ol>
<h1 id="实施">实施</h1>
<h2 id="1开启gzip">1.开启gzip</h2>
<p>这个比较简单，nginx配置下就行，配置文件最后}前添加</p>
<pre><code># 开启gzip
    gzip on;

    # 启用gzip压缩的最小文件，小于设置值的文件将不会压缩
    gzip_min_length 1k;

    # gzip 压缩级别，1-9，数字越大压缩的越好，也越占用CPU时间，后面会有详细说明
    gzip_comp_level 5;

    # 进行压缩的文件类型。javascript有多种形式。其中的值可以在 mime.types 文件中找到。
    gzip_types text/plain application/javascript application/x-javascript text/css application/xml text/javascript application/x-httpd-php image/jpeg image/gif image/png application/vnd.ms-fontobject font/ttf font/opentype font/x-woff image/svg+xml;

    # 是否在http header中添加Vary: Accept-Encoding，建议开启
    gzip_vary on;

    # 禁用IE 6 gzip
    gzip_disable &quot;MSIE [1-6]\.&quot;;

    # 设置压缩所需要的缓冲区大小     
    gzip_buffers 32 4k;

    # 设置gzip压缩针对的HTTP协议版本
    gzip_http_version 1.0;
</code></pre>
<h2 id="2路由懒加载">2.路由懒加载</h2>
<ul>
<li>在<code>babel.config.js</code>中配置plugins中增加如下内容（npm install -D-S  @babel/syntax-dynamic-import）后，可以识别router.js中的import按需加载,<code>component: () =&gt; import(/* webpackChunkName:'page404' */ './views/404.vue'),</code>, <code>/* webpackChunkName:'page404' */</code>魔法注释可以定义打包后产出的chunk文件名</li>
</ul>
<pre><code>    &quot;plugins&quot;: [
        [
        &quot;@babel/syntax-dynamic-import&quot;
        ]
    ]
</code></pre>
<h2 id="3ui组件按需加载">3.UI组件按需加载</h2>
<ul>
<li>vant提供按需加载能力，在babel中添加如下代码，即可在组件中<code>import { Button } from 'vant'</code>,<code>components: { vanButton: Buttom }</code></li>
</ul>
<pre><code>  &quot;plugins&quot;: [
    ['import', {
      libraryName: 'vant',
      libraryDirectory: 'es',
      style: true
    }, 'vant']
  ]
</code></pre>
<ul>
<li>lazyload, toast, dialog等有函数类型的组件需要全局引入并<code>Vue.use()</code>否则组件模式会有坑</li>
</ul>
<h2 id="4插件通过cdn引用">4.插件通过cdn引用</h2>
<ul>
<li>在<code>index.html</code>中引入cdn文件</li>
</ul>
<pre><code>  &lt;link rel=&quot;stylesheet&quot; href=&quot;https://cdn.jsdelivr.net/npm/vant@2.4/lib/index.css&quot;&gt;
    &lt;!-- CDN --&gt;
    &lt;script src=&quot;https://cdn.bootcss.com/vue-router/3.1.3/vue-router.min.js&quot;&gt;&lt;/script&gt;
    &lt;script src=&quot;https://cdn.bootcss.com/vue/2.6.10/vue.runtime.min.js&quot;&gt;&lt;/script&gt;
    &lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/moment.js/2.24.0/moment.min.js&quot;&gt;&lt;/script&gt;
    &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vant@2.4/lib/vant.min.js&quot;&gt;&lt;/script&gt;
</code></pre>
<ul>
<li>在<code>vue.config.js</code>中设定production模式不打包对应的插件</li>
</ul>
<pre><code>  configureWebpack: config =&gt; {
    if (process.env.NODE_ENV === &quot;production&quot;) {
      config.externals = {
        'vue': 'Vue',
        'vue-router': 'VueRouter',
        'moment': 'moment',
        'vant': 'Vant'
      }
    }
  }
</code></pre>
<h2 id="5白屏增内容">5.白屏增内容</h2>
<ul>
<li>修改标题为人性化语言</li>
<li>在<code>&lt;div id=&quot;app&quot;&gt;&lt;/div&gt;</code>中添加加载提示内容，如loading图等<br>
<img src="https://blog.te.6foo.cn/post-images/1578973111183.gif" alt="" loading="lazy"></li>
</ul>
<h1 id="如何查出是哪些包撑大了vendors文件造成首屏慢">*如何查出是哪些包撑大了vendors文件造成首屏慢</h1>
<p>使用<code>webpack-bundle-analyzer</code>进行分析</p>
<ul>
<li><code>npm install -D webpack-bundle-analyzer</code>，在<code>vue.config.js</code>中配置</li>
</ul>
<pre><code>chainWebpack: (config) =&gt; {
    if (process.env.npm_config_report) {
      config
        .plugin('webpack-bundle-analyzer')
        .use(require('webpack-bundle-analyzer').BundleAnalyzerPlugin)
    }
  }
</code></pre>
<ul>
<li>在<code>package.json</code>中添加scripts <code>&quot;analyz&quot;: &quot;npm_config_report=true npm run build&quot;</code>，运行后会自动打开浏览器展示各个包大小<br>
<img src="https://blog.te.6foo.cn/post-images/1578973324739.jpg" alt="" loading="lazy"></li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[PHP的workderman部署socket服务，龙兵5.99.77学习研究]]></title>
        <id>https://blog.te.6foo.cn/post/php-de-workderman-bu-shu-socket-fu-wu</id>
        <link href="https://blog.te.6foo.cn/post/php-de-workderman-bu-shu-socket-fu-wu">
        </link>
        <updated>2020-01-05T01:51:05.000Z</updated>
        <content type="html"><![CDATA[<h1 id="宝塔面板设置">宝塔面板设置</h1>
<h2 id="1nginx配置">1.nginx配置</h2>
<pre><code>location /longbingwss
{
proxy_pass http://127.0.0.1:2345;
proxy_http_version 1.1;
proxy_set_header Upgrade $http_upgrade;
proxy_set_header Connection &quot;Upgrade&quot;;
proxy_set_header X-Real-IP $remote_addr;
}
</code></pre>
<h2 id="2php配置">2.php配置</h2>
<ul>
<li>需要安装<code>ionCube``fileinfo``redis</code> 插件，如果有多个php版本，只能一个安装redis插件（宝塔面板中）</li>
<li>需要解除禁用函数<code>pcntl_signal</code>和<code>pcntl_fork</code></li>
<li>宝塔如果装有多个php版本，需要在网站-php命令行版本切换到所需版本</li>
</ul>
<h2 id="3启动方式">3.启动方式</h2>
<p><code>php api.php start -d</code>启动，其中<code>api.php</code>为实际执行路径</p>
<h2 id="4关闭方式">4.关闭方式</h2>
<p>常规关闭方法是workerman目录下<code>php api.php stop</code><br>
如果无法关闭成功，先用<code>lsof -i:端口号</code> 找到相应端口进程，再用<code>kill -9 进程号</code>强制关闭，<code>kill -9 $(lsof -i tcp:2345 -t)</code>，可以一步到位。</p>
<h1 id="龙兵智能名片59977的适配方式">龙兵智能名片5.99.77的适配方式</h1>
<h2 id="1微擎开启redis">1.微擎开启redis</h2>
<ul>
<li>首先在<code>data/config.php</code>文件中，配置redis，密码按实际配置<pre><code>  $config['setting']['redis']['server'] = '127.0.0.1';  //默认本地，你也可以用云库地址（远程）
  $config['setting']['redis']['port'] = 6379;   //默认端口
  $config['setting']['redis']['pconnect'] = 1; 
  $config['setting']['redis']['auth'] = '';  //redis密码, 默认为空
  $config['setting']['redis']['requirepass'] = '';   //redis密码，默认为空，没用人人商城删除这行
  $config['setting']['redis']['timeout'] = 1;
</code></pre>
</li>
<li>此时并未开启需要修改这行<code>$config['setting']['cache'] = 'redis'; // 默认是mysql，改为redis</code></li>
<li><img src="https://blog.te.6foo.cn/post-images/1578203578908.jpg" alt="" loading="lazy"></li>
</ul>
<h2 id="2微擎开启workerman">2.微擎开启workerman</h2>
<p>微擎配置 data/config.php 增加如下代码</p>
<pre><code>// -------------------------- CONFIG WORKMAN --------------------------- //
$config['setting']['workerman']['server'] = '0.0.0.0';
$config['setting']['workerman']['port'] = 2345;
</code></pre>
<h2 id="3龙兵启动方式">3.龙兵启动方式</h2>
<ul>
<li>cd到插件workerman目录下，运行<code>sh start.sh</code></li>
<li>宝塔面板定时任务，每分钟执行一次<code>cd workerman目录``php start.php -d</code>脚本(不启动也能用，应该是为了方式进程被杀)</li>
</ul>
<h1 id="龙兵59977的修复">龙兵5.99.77的修复</h1>
<h2 id="动态-列表无法加载">动态-列表无法加载</h2>
<p>在<code>ims_longbing_card_timeline</code>表中，增加<code>company_id</code>字段int类型，和<code>is_company</code>字段int类型</p>
<h2 id="im通信前后端不匹配">IM通信前后端不匹配</h2>
<p>修改api.php，主要是修正了<code>$data</code>的引用问题，应该是<code>$data['data']</code>，通信的回参缺少了<code>action,data,target_id, user_id</code>导致小程序无法解析，修改如下</p>
<pre><code>&lt;?php

use Workerman\Worker;
use Workerman\Lib\Timer;

require_once __DIR__ . '/Autoloader.php';
require_once __DIR__ . '/mysql/src/Connection.php';
//require_once __DIR__ . '/../config.php';
// 心跳间隔55秒
define('HEARTBEAT_TIME', 55);

define('IN_IA', 'tmp');
include_once __DIR__ . '/../../../data/config.php';
$workman_server = '0.0.0.0';
$workman_port = 2345;
if (!empty($config) &amp;&amp; isset($config['setting'])
    &amp;&amp; isset($config['setting']['workerman'])
    &amp;&amp; isset($config['setting']['workerman']['server'])
    &amp;&amp; $config['setting']['workerman']['server']) {
    $workman_server = $config['setting']['workerman']['server'];
}
if (!empty($config) &amp;&amp; isset($config['setting'])
    &amp;&amp; isset($config['setting']['workerman'])
    &amp;&amp; isset($config['setting']['workerman']['port'])
    &amp;&amp; $config['setting']['workerman']['port']) {
    $workman_port = $config['setting']['workerman']['port'];
}
// 初始化一个worker容器，监听2345端口
//$worker = new Worker('websocket://0.0.0.0:2345');
$worker = new Worker('websocket://' . $workman_server . ':' . $workman_port);
// ====这里进程数必须必须必须设置为1====
$worker-&gt;count = 1;
// 新增加一个属性，用来保存uid到connection的映射(uid是用户id或者客户端唯一标识)
$worker-&gt;uidConnections = array();

$worker-&gt;onWorkerStart = function ($worker) {
    // 将db实例存储在全局变量中(也可以存储在某类的静态成员中)
    global $db, $config;
//    $db = new \Workerman\MySQL\Connection(WM_HOST, WM_PORT, WM_USER, WM_PASSWORD, WM_DBNAME, WM_CHARSET);
//    $config = file('../../../data/config.php');
    $host = '';
    $username = '';
    $password = '';
    $port = '';
    $database = '';
    $tablepre = '';
    if (!empty($config)) {
        if (isset($config['db']) &amp;&amp; isset($config['db']['master']) &amp;&amp; isset($config['db']['master']['host'])) {
            $host = $config['db']['master']['host'];
        }
        if (isset($config['db']) &amp;&amp; isset($config['db']['master']) &amp;&amp; isset($config['db']['master']['username'])) {
            $username = $config['db']['master']['username'];
        }
        if (isset($config['db']) &amp;&amp; isset($config['db']['master']) &amp;&amp; isset($config['db']['master']['password'])) {
            $password = $config['db']['master']['password'];
        }
        if (isset($config['db']) &amp;&amp; isset($config['db']['master']) &amp;&amp; isset($config['db']['master']['port'])) {
            $port = $config['db']['master']['port'];
        }
        if (isset($config['db']) &amp;&amp; isset($config['db']['master']) &amp;&amp; isset($config['db']['master']['database'])) {
            $database = $config['db']['master']['database'];
        }
        if (isset($config['db']) &amp;&amp; isset($config['db']['master']) &amp;&amp; isset($config['db']['master']['tablepre'])) {
            $tablepre = $config['db']['master']['tablepre'];
        }


        if (isset($config['db']) &amp;&amp; isset($config['db']['host'])) {
            $host = $config['db']['host'];
        }
        if (isset($config['db']) &amp;&amp; isset($config['db']['username'])) {
            $username = $config['db']['username'];
        }
        if (isset($config['db']) &amp;&amp; isset($config['db']['password'])) {
            $password = $config['db']['password'];
        }
        if (isset($config['db']) &amp;&amp; isset($config['db']['port'])) {
            $port = $config['db']['port'];
        }
        if (isset($config['db']) &amp;&amp; isset($config['db']['database'])) {
            $database = $config['db']['database'];
        }
        if (isset($config['db']) &amp;&amp; isset($config['db']['tablepre'])) {
            $tablepre = $config['db']['tablepre'];
        }

    }
    $db = new \Workerman\MySQL\Connection($host, $port, $username, $password, $database, 'utf8mb4');

    Timer::add(1, function () use ($worker) {
        $time_now = time();
        foreach ($worker-&gt;connections as $connection) {
            // 有可能该connection还没收到过消息，则lastMessageTime设置为当前时间
            if (empty($connection-&gt;lastMessageTime)) {
                $connection-&gt;lastMessageTime = $time_now;
                continue;
            }
            // 上次通讯时间间隔大于心跳间隔，则认为客户端已经下线，关闭连接
            if ($time_now - $connection-&gt;lastMessageTime &gt; HEARTBEAT_TIME) {
                $connection-&gt;close();
            }
        }
    });
};

// 客户端练上来时，即完成TCP三次握手后的回调
$worker-&gt;onConnect = function ($connection) {
    /**
     * 客户端websocket握手时的回调onWebSocketConnect
     * 在onWebSocketConnect回调中获得nginx通过http头中的X_REAL_IP值
     */
    $connection-&gt;onWebSocketConnect = function ($connection) {
        /**
         * connection对象本没有realIP属性，这里给connection对象动态添加个realIP属性
         * 记住php对象是可以动态添加属性的，你也可以用自己喜欢的属性名
         */
        $connection-&gt;realIP = $_SERVER['HTTP_X_REAL_IP'];
    };
};

// 当有客户端发来消息时执行的回调函数
$worker-&gt;onMessage = function ($connection, $data) {
    global $worker, $db, $config;
    
	$data2 = $data;
    $data = json_decode($data, true);
    
    $connection-&gt;lastMessageTime = time();

//    $config = file('../../../data/config.php');

    //  心跳检测
    if ($data['data']['check'] == '78346+SJDHFA.longbing') {
        $msg = [
            'errno' =&gt; 0,
            'message' =&gt; '接收成功',
            'data' =&gt; $data['data'],
            'type' =&gt; '',
            'action' =&gt; 'checkWs'
        ];
        $msg = json_encode($msg, JSON_UNESCAPED_UNICODE);
        $connection-&gt;send($msg);

        return false;
    }

    $tablepre = '';
    if (!empty($config)) {
        if (isset($config['db']) &amp;&amp; isset($config['db']['master']) &amp;&amp; isset($config['db']['master']['tablepre'])) {
            $tablepre = $config['db']['master']['tablepre'];
        }

        if ($tablepre == '') {
            if (isset($config['db']) &amp;&amp; isset($config['db']['master']) &amp;&amp; isset($config['db']['tablepre'])) {
                $tablepre = $config['db']['tablepre'];
            }
        }
    }


    //  检测链接是否成功
    if (isset($data['ping'])) {
        $connection-&gt;send('pong');

        //  新版本不需要了
//        $list = $db-&gt;query(&quot;SELECT * FROM `&quot; . $tablepre .&quot;longbing_card_message` WHERE target_id={$data['user_id']} &amp;&amp; user_id = {$data['target_id']} &amp;&amp; status = 1&quot;);
//
//        if (is_array($list) &amp;&amp; !empty($list)) {
//            foreach ($list as $k =&gt; $v) {
//                if (isset($v['message_type']))
//                {
//                    $v['type'] = $v['message_type'];
//                }
//
//
//                $msg = [
//                    'errno' =&gt; 0,
//                    'message' =&gt; '接收成功_1',
//                    'data' =&gt; $v['content'],
////                    'data' =&gt; $v,
//                    'type' =&gt; $v['message_type'],
//                    'data2'=&gt; $v
//                ];
//                $msg = json_encode($msg, JSON_UNESCAPED_UNICODE);
//                $connection-&gt;send($msg);
////                $db-&gt;query(&quot;UPDATE `&quot; . $tablepre . &quot;longbing_card_message` SET status = 2 WHERE id = {$v['id']}&quot;);
//            }
//        }

        // 判断当前客户端是否已经验证,即是否设置了uid
        if (!isset($connection-&gt;uid)) {
            $connection-&gt;uid = $data['user_id'];
            /* 保存uid到connection的映射，这样可以方便的通过uid查找connection，
             * 实现针对特定uid推送数据
             */
            $worker-&gt;uidConnections[$connection-&gt;uid] = $connection;
        }

        return false;
    }

    //  获取当前用户的未读消息数量
    if (isset($data['unread']) &amp;&amp; isset($data['to_uid']) &amp;&amp; isset($data['user_id'])
        &amp;&amp; $data['unread'] &amp;&amp; $data['user_id']) {

        $info = $db-&gt;query(&quot;SELECT * FROM `&quot; . $tablepre . &quot;longbing_card_user` WHERE id={$data['user_id']}&quot;);
		
        //  身为客户, 指定名片的未读消息
        if ($data['to_uid']) {
            $list = $db-&gt;query(&quot;SELECT * FROM `&quot; . $tablepre . &quot;longbing_card_message` 
            WHERE target_id={$data['user_id']} &amp;&amp; user_id = {$data['to_uid']} &amp;&amp; status = 1&quot;);
        } //  身为客户, 所有的未读消息
        else {
            $list = $db-&gt;query(&quot;SELECT * FROM `&quot; . $tablepre . &quot;longbing_card_message` 
            WHERE target_id={$data['user_id']} &amp;&amp; status = 1&quot;);
        }
        $user_count = count($list);
        $staff_count = 0;

        //  当这个人也是员工的时候
        if ($info &amp;&amp; $info[0]['is_staff'] == 1) {
            $list = $db-&gt;query(&quot;SELECT * FROM `&quot; . $tablepre . &quot;longbing_card_message` 
            WHERE target_id={$data['user_id']} &amp;&amp; status = 1&quot;);
            $count = count($list);
            $staff_count = $count;
        }


        $msg = [
            'errno' =&gt; 0,
            'message' =&gt; '请求成功',
            'data' =&gt; ['user_count' =&gt; $user_count, 'staff_count' =&gt; $staff_count],
            'type' =&gt; 'unread',
            'msg' =&gt; 'unread',
        ];

        $msg = json_encode($msg, JSON_UNESCAPED_UNICODE);
        $connection-&gt;send($msg);

        // 判断当前客户端是否已经验证,即是否设置了uid
        if (!isset($connection-&gt;uid)) {
            $connection-&gt;uid = $data['user_id'];
            /* 保存uid到connection的映射，这样可以方便的通过uid查找connection，
             * 实现针对特定uid推送数据
             */
            $worker-&gt;uidConnections[$connection-&gt;uid] = $connection;
        }

        return false;
    }


    $data = $data['data'];
    if (isset($data['goods_id'])) {
        $goods_info = $db-&gt;query(&quot;SELECT * FROM `&quot; . $tablepre . &quot;longbing_card_goods` WHERE id={$data['goods_id']}&quot;);
        $data['content'] = '您好！我想咨询下商品：' . $goods_info[0]['name'] . '的相关信息。';
        $data['type'] = 'text';
    }
    if (!isset($data['user_id']) || !isset($data['target_id']) || !isset($data['content']) || !isset($data['uniacid'])) {
        $msg = [
            'errno' =&gt; -1,
	        // 'message' =&gt; '请传入必要参数' .$data['user_id'] .'-'.$data['target_id'] .'-'.$data['content'] .'-'.$data['uniacid'],
            'message' =&gt; $data2,
            'data' =&gt; []
        ];
        $msg = json_encode($msg, JSON_UNESCAPED_UNICODE);
        $connection-&gt;send($msg);
        return false;
    }

    $user_id = $data['user_id'];
    $target_id = $data['target_id'];
    $content = $data['content'];
    $uniacid = $data['uniacid'];
    $type = $data['type'];


    $check1 = $db-&gt;query(&quot;SELECT * FROM `&quot; . $tablepre . &quot;longbing_card_chat` WHERE user_id={$user_id} &amp;&amp; target_id = {$target_id}&quot;);

    if (empty($check1)) {

        $check2 = $db-&gt;query(&quot;SELECT * FROM `&quot; . $tablepre . &quot;longbing_card_chat` WHERE user_id={$target_id} &amp;&amp; target_id = {$user_id}&quot;);

        if (empty($check2)) {
            $insert_id = $db-&gt;insert($tablepre . 'longbing_card_chat')-&gt;cols(array(
                    'user_id' =&gt; $user_id,
                    'target_id' =&gt; $target_id,
                    'uniacid' =&gt; $uniacid,
                    'create_time' =&gt; time(),
                    'update_time' =&gt; time(),
                )
            )-&gt;query();
            $chat_id = $insert_id;
        } else {
            $chat_id = $check2[0]['id'];
        }
    } else {
        $chat_id = $check1[0]['id'];
    }

	
    if (!$chat_id) {
        $msg = [
            'errno' =&gt; -1,
            'message' =&gt; '系统错误',
            'data' =&gt; []
        ];
        $msg = json_encode($msg, JSON_UNESCAPED_UNICODE);
        $connection-&gt;send($msg);
        return false;
    }


    $install_data = array(
        'chat_id' =&gt; $chat_id,
        'user_id' =&gt; $user_id,
        'target_id' =&gt; $target_id,
        'content' =&gt; $content,
        'uniacid' =&gt; $uniacid,
        'message_type' =&gt; $type,
        'create_time' =&gt; time(),
        'update_time' =&gt; time(),
    );

    $insert_id = $db-&gt;insert($tablepre . 'longbing_card_message')-&gt;cols($install_data)-&gt;query();

    if (!$insert_id) {
        $msg = [
            'errno' =&gt; -1,
            'message' =&gt; '系统错误!',
            'data' =&gt; []
        ];
        $msg = json_encode($msg, JSON_UNESCAPED_UNICODE);
        $connection-&gt;send($msg);
        return false;
    } else {
        $install_data['id'] = $insert_id;
    }

    // 判断当前客户端是否已经验证,即是否设置了uid
    if (!isset($connection-&gt;uid)) {
        // 没验证的话把第一个包当做uid（这里为了方便演示，没做真正的验证）
        $connection-&gt;uid = $user_id;
        /* 保存uid到connection的映射，这样可以方便的通过uid查找connection，
         * 实现针对特定uid推送数据
         */
        $worker-&gt;uidConnections[$connection-&gt;uid] = $connection;
//        $connection-&gt;send('login success, your uid is ' . $connection-&gt;uid);
    }

//    file_put_contents('api.txt', 0 . PHP_EOL, FILE_APPEND);
//    mark($user_id, $target_id, $uniacid);
    sendMessageByUid($target_id, $content, $connection, $uniacid, $insert_id, $tablepre, $install_data, $user_id);

    return false;
    // 其它逻辑，针对某个uid发送 或者 全局广播
    // 假设消息格式为 uid:message 时是对 uid 发送 message
    // uid 为 all 时是全局广播
//    list($recv_uid, $message) = explode(':', $data);
    // 全局广播
    if ($target_id == 'all') {
        broadcast($content);
    } // 给特定uid发送
    else {
        sendMessageByUid($target_id, $content);
    }
};

// 当有客户端连接断开时
$worker-&gt;onClose = function ($connection) {
    global $worker;
    // $connection-&gt;send($connection-&gt;uid);
    // if (isset($connection-&gt;uid)) {
        // 连接断开时删除映射
        // unset($worker-&gt;uidConnections[$connection-&gt;uid]);
    // }
};

// 向所有验证的用户推送数据
function broadcast($message)
{
    global $worker;
    foreach ($worker-&gt;uidConnections as $connection) {
        $connection-&gt;send($message);
    }
}

// 针对uid推送数据
function sendMessageByUid($uid, $message, $con, $uniacid = 0, $insert_id = 0, $tablepre = '', $data2 = array(), $user_id = 0)
{
    global $worker, $db;


    $info = $db-&gt;query(&quot;SELECT * FROM `&quot; . $tablepre . &quot;longbing_card_user` WHERE id={$uid}&quot;);


    //  未读消息数量
    $list = $db-&gt;query(&quot;SELECT * FROM `&quot; . $tablepre . &quot;longbing_card_message` 
            WHERE target_id={$uid} &amp;&amp; status = 1 &amp;&amp; user_id={$user_id}&quot;);

    $user_count = count($list);
    $staff_count = 0;

    //  当这个人也是员工的时候
    if ($info &amp;&amp; $info[0]['is_staff'] == 1) {
        $list = $db-&gt;query(&quot;SELECT * FROM `&quot; . $tablepre . &quot;longbing_card_message` 
            WHERE target_id={$uid} &amp;&amp; status = 1&quot;);
        $count = count($list);
        $staff_count = $count;
    }


    if (isset($worker-&gt;uidConnections[$uid])) {
        $connection = $worker-&gt;uidConnections[$uid];

        if (isset($data2['message_type'])) {
            $data2['type'] = $data2['message_type'];
        }
        //  兼容旧版本
        $msg = [
            'errno' =&gt; 0,
            'message' =&gt; '接收成功_2',
            'user_count' =&gt; $user_count,
            'staff_count' =&gt; $staff_count,
            'type' =&gt; $data2['message_type'],
            'msg' =&gt; 'getMsg',
            'data' =&gt; $data2,
            'action' =&gt; 'sendMessage'
        ];
        $msg = json_encode($msg, JSON_UNESCAPED_UNICODE);
        $connection-&gt;send($msg);
        $msg = [
            'errno' =&gt; 0,
            'message' =&gt; '发送成功_2',
            'data' =&gt; $data2,
            'msg' =&gt; 'getMsg',
            'action' =&gt; 'sendMessage',
            'user_id'=&gt;$data2['user_id'],
            'target_id'=&gt;$data2['target_id']
        ];
        $msg = json_encode($msg, JSON_UNESCAPED_UNICODE);
        $con-&gt;send($msg);
        if ($insert_id) {
//            $db-&gt;query(&quot;UPDATE `&quot; . $tablepre . &quot;longbing_card_message` SET status = 2 WHERE id = {$insert_id}&quot;);
        }
        return false;
    } else {

    }
    $msg = [
        'errno' =&gt; 0,
        'message' =&gt; '发送成功_1',
        'data' =&gt; $data2,
        'action' =&gt; 'sendMessage',
        'user_id' =&gt; $data2['user_id'],
        'target_id' =&gt; $data2['target_id']
    ];
    $msg = json_encode($msg, JSON_UNESCAPED_UNICODE);
    $con-&gt;send($msg);
}

function mark($uid, $target_id, $uniacid)
{
//    file_put_contents('api.txt', $uid . '-' . $target_id . '-' . $uniacid . PHP_EOL, FILE_APPEND);
    global $worker, $db;
//    $check_user = $db-&gt;select('*')
//        -&gt;from('ims_longbing_card_user')
//        -&gt;where('id= :id')
//        -&gt;bindValues(array('id'=&gt;$uid))
//        -&gt;row();

    $check_user = $db-&gt;query(&quot;SELECT * FROM `ims_longbing_card_user` WHERE id={$uid}&quot;);
//    $check_user_tar = $db-&gt;select('*')
//        -&gt;from('ims_longbing_card_user')
//        -&gt;where('id= :id')
//        -&gt;bindValues(array('id'=&gt;$target_id))
//        -&gt;row();
    $check_user_tar = $db-&gt;query(&quot;SELECT * FROM `ims_longbing_card_user` WHERE id={$target_id}&quot;);
//    file_put_contents('api.txt', 1, FILE_APPEND);
    if (empty($check_user) || empty($check_user_tar))
        return false;
//    file_put_contents('api.txt', 2, FILE_APPEND);
    if ($check_user['is_staff']) {
        $staff_id = $check_user['id'];
        $user_id = $check_user_tar['id'];
    } else {
        $staff_id = $check_user_tar['id'];
        $user_id = $check_user['id'];
    }

    $check = $db-&gt;select('*')
        -&gt;from('ims_longbing_card_user_mark')
        -&gt;where('user_id= :user_id AND staff_id= :staff_id')
        -&gt;bindValues(array('user_id' =&gt; $user_id, 'staff_id' =&gt; $staff_id))
        -&gt;row();
    $check = $db-&gt;query(&quot;SELECT * FROM `ims_longbing_card_user_mark` WHERE user_id={$user_id} &amp;&amp; staff_id = {$staff_id}&quot;);

    if (empty($check)) {

//        file_put_contents('api.txt', 4, FILE_APPEND);
        $insert_id = $db-&gt;insert('ims_longbing_card_user_mark')-&gt;cols(array(
                'user_id' =&gt; $user_id,
                'staff_id' =&gt; $staff_id,
                'uniacid' =&gt; $uniacid,
                'mark' =&gt; 1,
                'create_time' =&gt; time(),
                'update_time' =&gt; time())
        )-&gt;query();
//        file_put_contents('api.txt', '$insert_id' . $insert_id, FILE_APPEND);
    }
    return true;
}


// 运行所有的worker（其实当前只定义了一个）
Worker::runAll();
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[PHP的接口请求后得到的是字符串，且中文是Unicode字符，并且无法转码时]]></title>
        <id>https://blog.te.6foo.cn/post/php-de-jie-kou-qing-qiu-hou-de-dao-de-shi-zi-fu-chuan-qie-zhong-wen-shi-unicode-zi-fu-bing-qie-wu-fa-zhuan-ma-shi</id>
        <link href="https://blog.te.6foo.cn/post/php-de-jie-kou-qing-qiu-hou-de-dao-de-shi-zi-fu-chuan-qie-zhong-wen-shi-unicode-zi-fu-bing-qie-wu-fa-zhuan-ma-shi">
        </link>
        <updated>2019-12-10T03:13:23.000Z</updated>
        <content type="html"><![CDATA[<p>看看字符串头部是不是有空格，trim()去掉后可解析</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[eggjs & puppeteer 简单爬取网站]]></title>
        <id>https://blog.te.6foo.cn/post/eggjs-and-puppeteer-jian-dan-pa-qu-wang-zhan</id>
        <link href="https://blog.te.6foo.cn/post/eggjs-and-puppeteer-jian-dan-pa-qu-wang-zhan">
        </link>
        <updated>2019-12-10T03:07:12.000Z</updated>
        <content type="html"><![CDATA[<p>TIPS:</p>
<ol>
<li>部署到centos7.6中时发现 puppeteer报错，打不开共享库，运行下面代码解决</li>
</ol>
<pre><code>yum -y install libX11 libXcomposite libXcursor libXdamage libXext libXi libXtst cups-libs libXScrnSaver libXrandr alsa-lib pango atk at-spi2-atk gtk3 
</code></pre>
<ol start="2">
<li>然后出现不能用root用户运行chrome的情况，在page.launch配置中，增加<code>args: ['--no-sandbox']</code>参数</li>
<li>对eggjs 后端发起的post请求，需要在header中加<code>X-Csrf-Token</code> ，来源是cookie，因为有内置security插件作用</li>
<li>用完browser一定要记得关闭  不然chrome会一直跑</li>
</ol>
<h3 id="正文开始">正文开始</h3>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[VUE在微信端History模式获取jssdk签名失败解决方案]]></title>
        <id>https://blog.te.6foo.cn/post/vue-zai-wei-xin-duan-history-mo-shi-huo-qu-jssdk-qian-ming-shi-bai-jie-jue-fang-an</id>
        <link href="https://blog.te.6foo.cn/post/vue-zai-wei-xin-duan-history-mo-shi-huo-qu-jssdk-qian-ming-shi-bai-jie-jue-fang-an">
        </link>
        <updated>2019-09-20T16:22:30.000Z</updated>
        <content type="html"><![CDATA[<h1 id="原因">原因</h1>
<p>vue-router切换的时候操作的都是浏览器的历史记录，iOS会把第一次刚进入时的URL作为真实URL，安卓会把当前URL作为真实URL。</p>
<p>所以导致后端在配置好的授权参数获得的config参数和微信sdk获取的参数是不一样的。</p>
<h1 id="解决方案">解决方案</h1>
<pre><code>{
  path: '/namecheck',
  component: NameCheck,
  beforeEnter:(to,from,next)=&gt;{
    var u = navigator.userAgent;
    var isiOS = !!u.match(/\(i[^;]+;( U;)? CPU.+Mac OS X/); //ios终端
    // XXX: 修复iOS版微信HTML5 History兼容性问题
    if (isiOS &amp;&amp; to.path !== location.pathname) {
      // 此处不可使用location.replace
      location.assign(to.fullPath)
    } else {
      next()
    }
  },
  name: 'namecheck',
  meta: {
    requireAuth: true,
  }
},
</code></pre>
<p>也可以用全局router拦截</p>
<pre><code>router.beforeEach(async (to, from, next) =&gt; {
  let originUrlArr = location.href.split('#')[0].split('://')
  let originUrl = originUrlArr[1].split('/')[0]
  window.initUrl = originUrlArr[0] + '://' + originUrl + to.fullPath
  let u = navigator.userAgent;
  let isiOS = !!u.match(/\(i[^;]+;( U;)? CPU.+Mac OS X/); //ios终端
  // XXX: 修复iOS版微信HTML5 History兼容性问题
  if (isiOS &amp;&amp; to.path !== location.pathname) {
    // 此处不可使用location.replace
    location.assign(to.fullPath)
  }else {
		next()
	}
})
</code></pre>
<h2 id="windowlocationassignurl-加载-url-指定的新的-html-文档-就相当于一个链接跳转到指定的url当前页面会转为新页面内容可以点击后退返回上一个页面">window.location.assign(url) ： 加载 URL 指定的新的 HTML 文档。 就相当于一个链接，跳转到指定的url，当前页面会转为新页面内容，可以点击后退返回上一个页面。</h2>
<h2 id="windowlocationreplaceurl-通过加载-url-指定的文档来替换当前文档-这个方法是替换当前窗口页面前后两个页面共用一个">window.location.replace(url) ： 通过加载 URL 指定的文档来替换当前文档 ，这个方法是替换当前窗口页面，前后两个页面共用一个</h2>
<p>窗口，所以是没有后退返回上一页的</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[JS对base64图片做压缩操作]]></title>
        <id>https://blog.te.6foo.cn/post/js-dui-base64-tu-pian-zuo-ya-suo-cao-zuo</id>
        <link href="https://blog.te.6foo.cn/post/js-dui-base64-tu-pian-zuo-ya-suo-cao-zuo">
        </link>
        <updated>2019-08-29T09:05:12.000Z</updated>
        <content type="html"><![CDATA[<h1 id="获取原图base64宽高">获取原图base64,宽高</h1>
<pre><code>var reader =new FileReader();
reader.readAsDataURL(imgFile);
reader.onloadend=function(){ //文件读取结束的时候上传到服务器
	var img =document.createElement(&quot;img&quot;);
	img.src = reader.result;
	var width = img.width;
	var height = img.height;
	// 调用压缩
	var resultBase64 = compressImg(img, width, height);
})
</code></pre>
<h1 id="压缩主函数">压缩主函数</h1>
<pre><code>function compress (img, width, height) {
	if(img.src.length &lt;2000000) { //小于200K的压缩
return img.src;
}
//用于压缩图片的canvas
console.log(width + &quot;,&quot; + height)
let canvas = document.createElement(&quot;canvas&quot;);
let ctx = canvas.getContext('2d');

// 瓦片canvas
// var tCanvas = document.createElement(&quot;canvas&quot;);
// var tctx = tCanvas.getContext(&quot;2d&quot;);

let initSize = img.src.length;
// console.log(img.src)

var ratio;
if ((ratio = width * height / 4000000) &gt; 1) {
ratio *=10;

width /= ratio;
height /= ratio;
} else {
ratio = 5;
}
console.log('ratio=' +ratio)
canvas.width = width * 2;
console.log(width)
canvas.height = height * 2;
//铺底色
ctx.fillStyle = &quot;#fff&quot;;
ctx.fillRect(0, 0, canvas.width, canvas.height);
//如果图片像素大于100万则使用瓦片绘制
// var count;
// if ((count = width * height / 1000000) &gt; 1) {
// console.log('count='+count)
// count = ~~(Math.sqrt(count) + 1); //计算要分成多少块瓦片
// //计算每块瓦片的宽和高
// var nw = ~~(width / count);
// var nh = ~~(height / count);
// tCanvas.width = nw;
// tCanvas.height = nh;
// for (var i = 0; i &lt; count; i++) {
// for (var j = 0; j &lt; count; j++) {
// tctx.drawImage(img, i * nw * ratio, j * nh * ratio, nw * ratio * 2, nh * ratio * 2, 0, 0, nw, nh);
// ctx.drawImage(tCanvas, i * nw, j * nh, nw * 2, nh * 2);
// }
// }
// } else {
ctx.drawImage(img, 0, 0, width * 2, height * 2);
// }
//进行最小压缩
let dataURL = canvas.toDataURL('image/jpeg', 1);

console.log('压缩前：' + initSize);
console.log('压缩后：' + dataURL.length);
console.log('压缩率：' + ~~(100 * (initSize - dataURL.length) / initSize) + &quot;%&quot;);
console.log(dataURL)
return dataURL;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[centOS+宝塔面板搭建frp内网穿透]]></title>
        <id>https://blog.te.6foo.cn/post/centosbao-ta-mian-ban-da-jian-frp-nei-wang-chuan-tou</id>
        <link href="https://blog.te.6foo.cn/post/centosbao-ta-mian-ban-da-jian-frp-nei-wang-chuan-tou">
        </link>
        <updated>2019-08-10T07:09:09.000Z</updated>
        <summary type="html"><![CDATA[<p>用惯了ngrok 要不要换个口味，frp似乎更加简便。<br>
抛开稳定性，个人认为ngrok可以每次启动定义端口和子域名，<br>
而frp可以配置多个项目一键启动</p>
]]></summary>
        <content type="html"><![CDATA[<p>用惯了ngrok 要不要换个口味，frp似乎更加简便。<br>
抛开稳定性，个人认为ngrok可以每次启动定义端口和子域名，<br>
而frp可以配置多个项目一键启动</p>
<!-- more -->
<h1 id="服务端">服务端</h1>
<h2 id="1-下载linux-amd64包当前最新版本0282-releases仓库-github">1. 下载<a href="https://github.com/fatedier/frp/releases/download/v0.28.2/frp_0.28.2_freebsd_amd64.tar.gz">linux-amd64</a>包，当前最新版本0.28.2。<a href="https://github.com/fatedier/frp/releases">releases仓库</a>  <a href="https://github.com/fatedier/frp">github</a></h2>
<h2 id="2-上传服务器解压">2. 上传服务器解压</h2>
<p>假设解压到了/www/frp目录</p>
<h2 id="3-编辑配置文件">3. 编辑配置文件</h2>
<p>服务端是<code>frps.ini</code>，配置信息如下：</p>
<pre><code>[common]
bind_addr = 0.0.0.0
# 绑定端口
bind_port = 5443
kcp_bind_port = 5443
# 控制面板端口
dashboard_port = 6443

#认证超时时间，默认900秒
authentication_timeout = 900

#服务端面板的登录用户名，自行设置，后面有用。
dashboard_user = YourUsername

#服务端面板的登录密码，自行设置，后面有用。
dashboard_pwd = YourPassword

#http端口，不要设置80，否则和宝塔面板端口号冲突
vhost_http_port = 808

#https端口，不要设置443，否则和宝塔面板端口号冲突
vhost_https_port = 909

#相当于客户端连接服务端的通关密码，随便设置，后面有用。
token = YourToken

max_pool_count = 50
tcp_mux = true

# 自定义404 页面，要用绝对路径哦！
custom_404_page = /www/frp/404.html

#你绑定域名的二级域名，假如绑定的是*.frp.domain.com，就填frp.domain.com。
subdomain_host = frp.domain.com
</code></pre>
<h2 id="4-设置开机自启">4. 设置开机自启</h2>
<ul>
<li>创建后台启动模版<br>
<code>touch /etc/systemd/system/frp.service</code></li>
<li>填写启动配置</li>
</ul>
<pre><code>[Unit]
Description=frps
After=network.target

[Service]
ExecStart=/root/frp_0.27.0_linux_amd64/frps -c /root/frp_0.27.0_linux_amd64/frps.ini 

[Install]
WantedBy=multi-user.target
</code></pre>
<ul>
<li>测试启动<br>
<code>启动测试 systemctl start frp.service</code><br>
<code>查看状态 systemctl status frp.service</code><br>
<code>正式启用 systemctl enable frp.service</code></li>
</ul>
<h2 id="5-更多配置参考文档">5. 更多配置<a href="https://github.com/fatedier/frp/blob/master/README_zh.md">参考文档</a></h2>
<h1 id="客户端">客户端</h1>
<h2 id="macos">MacOS</h2>
<h3 id="1-下载mac版release包">1. 下载mac版<a href="https://github.com/fatedier/frp/releases/download/v0.28.2/frp_0.28.2_darwin_amd64.tar.gz">release包</a></h3>
<h3 id="2-解压到任意目录-如~frp">2. 解压到任意目录 如~/frp</h3>
<h3 id="3-配置客户端配置文件frpcini运行时选择启动的文件名无所谓">3. 配置客户端配置文件<code>frpc.ini</code>(运行时选择启动的，文件名无所谓)</h3>
<pre><code>
[common]
#你的服务端IP地址
server_addr = frp.domain.com
server_port = 5443
# 如果服务端设置了token，这里也要加上
#token = YourToken

[web1]
type = http
#客户端所在内网的IP地址
local_ip = 127.0.0.1
local_port = localPort
#远程连接的端口号，可自行设置，远程http端口
remote_port = 808
#绑定二级域名的前缀
subdomain = web1

[web2]
# 协议为http（即80端口）
type = http
# 内部映射的IP
local_ip =127.0.0.1
# 内部映射为80端口
local_port = localPort
#远程连接的端口号，可自行设置，远程http端口
remote_port = 808
# 映射域名为
subdomain = web2
# 或者直接指定全域名（你只需要将域名解析到服务器上）
# custom_domains = web2.frp.domain.com

[ssh]
type = tcp
local_ip = 127.0.0.1
local_port = 22
# 远程端口
remote_port =远端ssh端口
</code></pre>
<h3 id="4-运行客户端">4. 运行客户端</h3>
<p><code>./frpc -c frpc.ini</code></p>
<h1 id="todo">TODO</h1>
<ol>
<li>其他客户端配置</li>
<li>服务端适配反向代理以使用80 和 443端口</li>
<li>docker配置</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[VUE]]></title>
        <id>https://blog.te.6foo.cn/post/vue</id>
        <link href="https://blog.te.6foo.cn/post/vue">
        </link>
        <updated>2019-07-18T05:28:47.000Z</updated>
        <content type="html"><![CDATA[<h1 id="vue">vue</h1>
<ol>
<li>
<p>mixin导入js中的变量方法的监听 <code>要在mixin载入点文件中通过watch来监听</code></p>
</li>
<li>
<p>vue中的修饰符</p>
</li>
</ol>
<pre><code>.prevent 阻止 touchmove 冒泡
</code></pre>
<ol start="3">
<li>弹出页面滑动操作影响父级页面滚动 <code>通过js阻止滚动事件冒泡</code> 解决；<br>
<strong>录音上滑取消可以此实现</strong></li>
</ol>
<pre><code>在vue中`.prevent`修饰符可以阻止`touchmove`冒泡实现遮罩阻止滑动 
.stop 阻止 click 冒泡
</code></pre>
<ol start="4">
<li>
<p>vue组件中也能传入Function，可执行传入操作（比如关闭蒙版后执行某操作）</p>
</li>
<li>
<p><code>template</code>中的变量如果需要经过函数处理的，如果处理函数中有<code>循环</code>，vue可能会不停渲染，造成页面卡死</p>
</li>
</ol>
<h1 id="router">router</h1>
<ol>
<li>vue路由按返回键来回跳的，可以是适当用<code>router.replace</code>进行路由跳转，<code>replace</code>表示替换当前<code>history</code>栈，类似与redirect;通常用的<code>router.push</code>是增加history栈</li>
</ol>
<h1 id="axios">axios</h1>
<ol>
<li>axios中执行formdata方式上传文件（不确定是不是在拦截器中写法有问题）</li>
</ol>
<pre><code>要用Axios.post方法去设置params和头，拦截器中无法修改content-type
Axios.post(
`http://${host}/appapi/api/MyCaseInfo/UploadFile`,
params,
  {
    'Content-Type': 'multipart/form-data'
  }
)
</code></pre>
<h1 id="vant">vant</h1>
<h2 id="0x00-van-list-组件-下拉刷新-上拉加载">0x00 van-list 组件 下拉刷新 上拉加载</h2>
<blockquote>
<p>如果列表的<code>height</code>小于<code>100vh</code>，会造成下拉刷新<code>pull refresh</code>和上拉加载<code>load</code>同时触发造成数据重复；定义全局变量pageIndex，获取数据的同时pageIndex++ 这样<code>load</code>的时候<code>pageIndex</code>是2，不会数据冗余</p>
</blockquote>
<h1 id="vue中的h5特性标签">vue中的H5特性标签</h1>
<h2 id="0x00-页面中需要加载多个音频">0x00 页面中需要加载多个音频</h2>
<ol>
<li>方式一（无完善demo）</li>
</ol>
<ul>
<li><code>data</code>中定义<code>音频文件链接</code>数组，创建单个公用<code>audio</code>标签，点击音频数组时对<code>audio</code>进行赋值，监听到音频<code>loaded</code>后，执行播放<code>play()</code></li>
<li>注意点：<strong>audio会直接load（就算src为空），更换src不自动reload，所以audio放进一个弹框，每次变更进行销毁</strong></li>
</ul>
<ol start="2">
<li>方式二（honeywell/CasemanageAPP）</li>
</ol>
<ul>
<li>
<p>页面同时渲染多个<code>audio</code></p>
<pre><code>&lt;div @click=&quot;togglePlay&quot;&gt;
  &lt;audio :id=&quot;'audio'+ index&quot; :src=&quot;voice[urlKey]&quot; @pause=&quot;onPause&quot; @loadedmetadata=&quot;onLoadedmetadata($event, index)&quot;&gt;&lt;/audio&gt;
&lt;/div&gt;
&lt;script&gt;
  togglePlay (index) {
    if (index === this.currentVoice &amp;&amp; this.playFlag) {
      this.currentVoiceEl.pause()
      this.currentVoice = null
      this.playFlag = false
    } else if (!this.playFlag || index !== this.currentVoice) {
      if (this.currentVoiceEl) {
        this.currentVoiceEl.pause()
        this.currentVoice = null
        this.playFlag = false
      }
      &lt;!-- 上一个的停止可能在下一个音频加载前面，只有settimeout能处理音频加载和停止的异步问题 --&gt;
      setTimeout(() =&gt; {
        this.currentVoice = index
        this.currentVoiceEl = document.getElementById('audio' + index)
        this.currentVoiceEl.play()
        this.playFlag = true
      }, 0);
    }
  }
&lt;/script&gt;
</code></pre>
</li>
</ul>
<h1 id="微信开发">微信开发</h1>
<ol>
<li>使用history模式路由，跳转到<code>相同路径</code>只改变<code>地址栏参数</code>，页面不刷新问题</li>
</ol>
<ul>
<li>方法一
<blockquote>
<p><s>通过中间页的beforeRouterEnter跳回。但是在ios下有问题，地址栏内容不改变，分享有问题。</s></p>
</blockquote>
</li>
<li>方法二
<blockquote>
<p>这个时候就应该用window.location.href进行强制跳转  才能保证跳转</p>
</blockquote>
</li>
</ul>
<h1 id="webview配置">webview配置</h1>
<h2 id="0x00-vue项目白屏">0x00 vue项目白屏</h2>
<ol>
<li>防止页面缓存</li>
</ol>
<ul>
<li>增加 webSettings.setCacheMode(WebSettings.<code>LOAD_NO_CACHE</code>);</li>
</ul>
<ol start="2">
<li>防止静态文件路径错误</li>
</ol>
<blockquote>
<p>webpack打包的vue项目默认是在根目录的纯前端项目，引入到webview中之后，实际的地址路径其实包含了前置路径，Andorid：android-assets/目录名/ 这时绝对路径就404了</p>
</blockquote>
<ul>
<li>webpack 4 + vue-cli3
<ul>
<li>新建vue.config.js文件 <a href="/default/vue.config.js">模板文件</a></li>
<li>修改baseUrl为<code>'./'</code>表示相对路径</li>
</ul>
</li>
<li>webpack 4 + vue-cli2
<ul>
<li>修改 config/index.js 中的 assetsPublicPath为<code>'./'</code>(该条未测)</li>
</ul>
</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[React]]></title>
        <id>https://blog.te.6foo.cn/post/react</id>
        <link href="https://blog.te.6foo.cn/post/react">
        </link>
        <updated>2019-07-18T05:28:28.000Z</updated>
        <content type="html"><![CDATA[<h1 id="react直接引入方式">react直接引入方式</h1>
<h2 id="0x00-基本">0x00 基本</h2>
<ol>
<li>
<p>引入<code>react/react-dom/babel/babel-polyfill</code>，解决IE兼容问题</p>
</li>
<li>
<p>script标签中<code>jsx</code>的type是<code>text/babel</code></p>
</li>
</ol>
<h2 id="0x01-区分jsx文件创建组件">0x01 区分jsx文件创建组件</h2>
<ol>
<li>
<p>引入全局变量绑定组件</p>
</li>
<li>
<p>通过js动态循环地址插入body中</p>
</li>
</ol>
<pre><code>var mail = {};
var mailComponent = {};
var cssPathList = [
  'src/common.css',
  'src/component/hon-title.css',
  'src/component/hon-body.css',
  'src/component/add-mail-main.css',
  'src/component/add-mail-box.css',
  'src/component/add-mail-checklist.css',
  'src/component/add-mail-choosetab.css',
];
for(var i = 0; i &lt; cssPathList.length; i++){
  var css = document.createElement(&quot;link&quot;);
  css.rel=&quot;stylesheet&quot;;
  css.href = cssPathList[i];
  document.head.appendChild(css);
}
var jsPathList = [
  'src/component/add-mail-main.jsx',
  'src/component/hon-title.jsx',
  'src/component/hon-body.jsx',
  'src/component/add-mail-box.jsx',
  'src/component/add-mail-checklist.jsx',
  'src/component/add-mail-choosetab.jsx',
  'src/component/add-mail-radiogroup.jsx',
  'src/component/add-mail-input.jsx',
  'src/index.jsx'
]
for (var i = 0 ; i &lt; jsPathList.length ; i++) {
  var script = document.createElement(&quot;script&quot;);
  script.type = &quot;text/babel&quot;;
  script.src = jsPathList[i];
  document.body.appendChild(script);
}
</code></pre>
<h2 id="0x02-vscode编辑器设置">0x02 VSCODE编辑器设置</h2>
<ol>
<li>在jsx文件中使用<code>emmet</code>，使用tab生成标签</li>
</ol>
<pre><code>&quot;emmet.syntaxProfiles&quot;: {
    &quot;javascript&quot;: &quot;jsx&quot;
},
&quot;emmet.includeLanguages&quot;: {
    &quot;javascript&quot;: &quot;javascriptreact&quot;
}
</code></pre>
<ol start="2">
<li>插件babel javascript -michael有问题, 会导致html里script标签高亮错误</li>
<li>插件 Full React 较好</li>
</ol>
<h2 id="直接引入方式的问题排查">直接引入方式的问题排查</h2>
<ol>
<li><code>index.html</code>中的<code>reactDom.render</code>是更组件，其中的props如果是变量，直接修改变量更新不会生效。</li>
</ol>
<blockquote>
<ul>
<li>异步请求需要传入props的实现方式</li>
<li>异步成功回调中书写reactDom.render内容，此时组件内componentWillReceiveProps(nextProps)，能获得更新的props</li>
</ul>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Ionic3]]></title>
        <id>https://blog.te.6foo.cn/post/ionic3</id>
        <link href="https://blog.te.6foo.cn/post/ionic3">
        </link>
        <updated>2019-07-18T05:28:07.000Z</updated>
        <content type="html"><![CDATA[<h1 id="ionic3开发">Ionic3开发</h1>
<h2 id="项目文件放在www文件夹下">项目文件放在www文件夹下</h2>
<h2 id="template中的静态文件引用要从www内部开始算如www下的img-则img不能开头">template中的静态文件引用要从www内部开始算，如www下的img 则'img/'，不能/开头</h2>
<h2 id="0x00-ionic3-打包">0x00 ionic3 打包</h2>
<ol>
<li><code>onic build andriod/ios</code> 编译的包是含有签名的</li>
<li>加上<code>--release</code> 包不含签名</li>
<li>加上<code>--prod</code> 包资源压缩 有效缩小包体积 减少启动白屏时间</li>
<li>发布<code>ionic cordova build browser</code>后浏览器包screen错误
<blockquote>
<p>解决方法： <code>config.xml</code>里的<code>splashScreen</code> 改为绝对路径，定义<code>splashScreenWidth</code>和<code>splashScreenHeight</code>的值</p>
</blockquote>
</li>
</ol>
<h2 id="0x01-ionic3-报错排查">0x01 ionic3 报错排查</h2>
<ol>
<li>
<p><code>Connection is not defined</code></p>
<blockquote>
<p>可能是缺少获取网络状态的Cordoba包，使用命令 cordova plugin add org.apache.cordova.network-information 安装</p>
</blockquote>
</li>
<li>
<p><code>because its MIME type ('text/plain') is not executable, and strict MIME type checking is enabled.</code></p>
<blockquote>
<p>可能是因为路径问题，返回的是404，不一定是文件类型错误</p>
</blockquote>
</li>
<li>
<p><code>queryelement of null</code></p>
<blockquote>
<p>有可能和tab toolbar heder有关（忘记这是个什么问题了）</p>
</blockquote>
</li>
<li>
<p>同时引用两个toolbar，content会不排除header高度，造成遮盖（这个问题也不确定是不是这么描述）</p>
</li>
<li>
<p>viewChild获取不到子元素问题</p>
<ul>
<li>方法1</li>
</ul>
<blockquote>
<p>子元素上应用了ngIf 会导致</p>
</blockquote>
<ul>
<li>方法2</li>
</ul>
<blockquote>
<p>改用viewChildren 来获取所有子元素（该方法未测试）</p>
</blockquote>
</li>
<li>
<p>组件内部使用ngDoCheck并调用interval计时器，可能会导致页面内存泄露，造成页面卡死</p>
</li>
</ol>
<h2 id="0x02-ionic3-特殊事件类型">0x02 ionic3 特殊事件类型</h2>
<ol>
<li>ionic3 press表示长按事件</li>
</ol>
<h2 id="0x03-ionic3-插件注意事项">0x03 ionic3 插件注意事项</h2>
<ol>
<li>
<p>调用原生拍照后转base64， 需要注意现在相机分辨率高，最好是先用<code>resizer</code>插件压缩一下，否则可能会失败。</p>
</li>
<li>
<p><code>backgroundMode</code>在<code>Android 8</code>下不生效，报错<code>bad notification...</code></p>
<blockquote>
<p>解决方法： 用命令<code>ionic cordova platforms remove android</code>删除<code>platform</code>里的<code>android</code>， 重新用<code>ionic cordova platforms add android@7.0.0</code> <a href="https://github.com/katzer/cordova-plugin-background-mode/issues/411">参考链接</a></p>
</blockquote>
</li>
</ol>
<h2 id="0x04-ionic3-请求拦截器-httpclient-请求体">0x04 ionic3 请求拦截器 HttpClient 请求体</h2>
<ol>
<li>在拦截器中获取<code>req.headers</code>里设定的自定义变量 使用<code>req.headers.get</code></li>
</ol>
<pre><code>intercept(req, next: HttpHandler){
    // 用req.headers.key取不到值
    let hadBaseurl = req.headers.get('hadBaseurl);
    // 用`req.paramas.key`取不到值
    let hastoken = req.params.get('hastoken');
}
</code></pre>
<ol start="2">
<li>在请求体中设置<code>req.headers</code>的自定义变量 使用<code>req.headers.set</code></li>
</ol>
<pre><code>intercept(req, next: HttpHandler){
   let newReq = req.clone({
     url: req.url
   })
   // 此处设置额外的头部，token之类
   newReq.headers = newReq.headers.set('Token', 'daflj3lklkdacjlk')
} 
</code></pre>
<ol start="3">
<li>在请求体中删除<code>req.headers</code>的变量 使用<code>req.headers.delete</code> <strong>生成的新值赋值给newReq</strong></li>
</ol>
<pre><code>intercept(req, next: HttpHandler){
   let newReq = req.clone({
     url: req.url
   })
   // 此处设置额外的头部，token之类
   newReq.headers = newReq.headers.delete('hadBaseurl')
   newReq.headers = newReq.headers.delete('uploadType')
} 
</code></pre>
<ol start="4">
<li>form表单方式上传文件的<code>content-type</code>应该是<code>multipart/form-data</code></li>
</ol>
<pre><code>intercept(req, next: HttpHandler) {
  // 非上传文件的content-type
  if (!req.headers.get('uploadType')){
    newReq.headers = newReq.headers.set('Content-Type', 'application/json')
  }
  // 上传文件content-type 默认的应该是multipart/form-data ，否则丢失boundary参数 无法解析formdata
}
</code></pre>
<h2 id="0x05-angular4-的pipe管道-如果要使用es6的promise语法需要asyncpipe异步管道">0x05 Angular4 的Pipe管道 如果要使用es6的Promise语法需要asyncPipe异步管道</h2>
<pre><code>&lt;img [src]=&quot;item | fileToBase64 | async&quot; alt=&quot;&quot;&gt;
加了 `| async` fileToBase64就可以使用promise/observable
</code></pre>
]]></content>
    </entry>
</feed>